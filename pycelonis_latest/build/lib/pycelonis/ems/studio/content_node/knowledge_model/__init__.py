"""Module to interact with Knowledge Models.

This module contains class to interact with Knowledge Models in Studio.

Typical usage example:

    ```python
    knowledge_model = package.get_knowledge_model(
        ANALYSIS_ID
    )
    knowledge_model = package.create_knowledge_model(
        content
    )
    knowledge_model.delete()
    ```
"""

import logging
from typing import Any, Dict, List, Optional, Tuple

import pandas as pd

from pycelonis import __version__
from pycelonis.ems.studio.content_node.knowledge_model.data_export import KnowledgeModelDataExport
from pycelonis.ems.studio.content_node import ContentNode
from pycelonis.ems.studio.content_node.knowledge_model.content import FinalKnowledgeModelContent
from pycelonis.ems.studio.content_node.knowledge_model.filter import Filter
from pycelonis.ems.studio.content_node.knowledge_model.kpi import Kpi
from pycelonis.ems.studio.content_node.knowledge_model.variable import Variable
from pycelonis.errors import PyCelonisQueryResolutionError
from pycelonis.pql.pql import PQL
from pycelonis.service.integration.service import DataCommand, DataQuery, QueryEnvironment
from pycelonis.service.semantic_layer.service import (
    DataCommandBatchRequest,
    DataCommandBatchTransport,
    FilterMetadata,
    FinalModelOptions,
    KpiMetadata,
    LayerComputeTransport,
    QueryRequest,
    SemanticLayerService,
    VariableMetadata,
    YamlMetadata,
    ProxyExportTypeV2,
    ExportKnowledgeModelByRootWithKeyRequest,
    QueryContext,
)
from pycelonis.utils.deprecation import deprecation_warning
from pycelonis.utils.parquet import read_parquet
from pycelonis_core.base.collection import CelonisCollection
from pycelonis_core.utils.errors import PyCelonisValueError

logger = logging.getLogger(__name__)


class KnowledgeModel(ContentNode):
    """Knowledge model object to interact with knowledge model specific studio endpoints."""

    def update(
        self, with_autogenerated_data_model_data: bool = True, with_variable_replacement: bool = True, **kwargs: Any
    ) -> None:
        """Pushes local changes of knowledge model `serialized_content` attribute to EMS.

        This only pushes changes made to `serialized_content`. Other attributes of the knowledge model will not be
        updated. Therefore, any changes have to be made by adjusting `serialized_content`.
        """
        updated_knowledge_model = SemanticLayerService.post_api_semantic_models(
            self.client,
            YamlMetadata(
                id=self.id,
                final_model_options=FinalModelOptions(
                    with_autogenerated_data_model_data=with_autogenerated_data_model_data,
                    with_variable_replacement=with_variable_replacement,
                    **kwargs,
                ),
                content=self.serialized_content,
            ),
        )
        self._update(updated_knowledge_model)

    ############################################################
    # KPI
    ############################################################
    def create_kpi(self, id_: str, display_name: str, pql: str, **kwargs: Any) -> "Kpi":
        """Creates new kpi with id, display name, and pql in given knowledge model.

        Args:
            id_: Id of new kpi.
            display_name: Display name of new kpi.
            pql: PQL query of new kpi.
            **kwargs: Additional parameters set for
                [KpiMetadata][pycelonis.service.semantic_layer.service.KpiMetadata] object.

        Returns:
            A Kpi object for newly created kpi.

        Examples:
            Create a kpi:
            ```python
            kpi = knowledge_model.create_kpi(
                id_="TEST_KPI",
                display_name="Test KPI",
                pql='COUNT("BSEG"."BELNR")',
            )
            ```
        """
        kpi_transport = SemanticLayerService.post_api_knowledge_model_layer_asset_id_kpis(
            self.client, self.id, KpiMetadata(id=id_, display_name=display_name, pql=pql, **kwargs)
        )
        logger.info("Successfully created kpi with id '%s'", kpi_transport.id)
        return Kpi.from_transport(self.client, self.id, kpi_transport)

    def get_kpi(self, id_: str) -> "Kpi":
        """Gets kpi with given id.

        Args:
            id_: Id of kpi.

        Returns:
            A Kpi object for kpi with given id.
        """
        kpi_transport = SemanticLayerService.get_api_knowledge_model_layer_asset_id_kpis_kpi_id(
            self.client, self.id, id_
        )
        return Kpi.from_transport(self.client, self.id, kpi_transport)

    def get_kpis(self) -> CelonisCollection["Kpi"]:
        """Gets all kpis of knowledge model.

        Returns:
            A list containing all kpis.
        """
        kpi_transports = SemanticLayerService.get_api_knowledge_model_layer_asset_id_kpis(self.client, self.id)
        return CelonisCollection(
            Kpi.from_transport(self.client, self.id, kpi_transport)
            for kpi_transport in kpi_transports
            if kpi_transport is not None
        )

    ############################################################
    # Variable
    ############################################################
    def create_variable(self, id_: str, display_name: str, value: str, **kwargs: Any) -> "Variable":
        """Creates new variable with id, display name, and pql in given knowledge model.

        Args:
            id_: Id of new variable.
            display_name: Display name of new variable.
            value: Value of new variable.
            **kwargs: Additional parameters set for
                [VariableMetadata][pycelonis.service.semantic_layer.service.VariableMetadata] object.

        Returns:
            A Variable object for newly created variable.

        Examples:
            Create a variable:
            ```python
            variable = knowledge_model.create_variable(
                id_="TEST_VARIABLE",
                display_name="Test Variable",
                value="Test Value",
            )
            ```
        """
        variable_transport = SemanticLayerService.post_api_knowledge_model_layer_asset_id_variables(
            self.client, self.id, VariableMetadata(id=id_, display_name=display_name, value=value, **kwargs)
        )
        logger.info("Successfully created variable with id '%s'", variable_transport.id)
        return Variable.from_transport(self.client, self.id, variable_transport)

    def get_variable(self, id_: str) -> "Variable":
        """Gets variable with given id.

        Args:
            id_: Id of variable.

        Returns:
            A Variable object for variable with given id.
        """
        variable_transport = SemanticLayerService.get_api_knowledge_model_layer_asset_id_variables_variable_id(
            self.client, self.id, id_
        )
        return Variable.from_transport(self.client, self.id, variable_transport)

    def get_variables(self) -> CelonisCollection["Variable"]:
        """Gets all variables of knowledge model.

        Returns:
            A list containing all variables.
        """
        variable_transports = SemanticLayerService.get_api_knowledge_model_layer_asset_id_variables(
            self.client, self.id
        )
        return CelonisCollection(
            Variable.from_transport(self.client, self.id, variable_transport)
            for variable_transport in variable_transports
            if variable_transport is not None
        )

    ############################################################
    # Filter
    ############################################################
    def create_filter(self, id_: str, display_name: str, pql: str, **kwargs: Any) -> "Filter":
        r"""Creates new filter with id, display name, and pql in given knowledge model.

        Args:
            id_: Id of new filter.
            display_name: Display name of new filter.
            pql: PQL query of new filter.
            **kwargs: Additional parameters set for
                [FilterMetadata][pycelonis.service.semantic_layer.service.FilterMetadata] object.

        Returns:
            A Filter object for newly created filter.

        Examples:
            Create a filter:
            ```python
            filter = knowledge_model.create_filter(
                id_="TEST_FILTER",
                display_name="Test FILTER",
                pql='FILTER "BSEG"."BELNR" = \'TEST\'',
            )
            ```
        """
        filter_transport = SemanticLayerService.post_api_knowledge_model_layer_asset_id_filters(
            self.client, self.id, FilterMetadata(id=id_, display_name=display_name, pql=pql, **kwargs)
        )
        logger.info("Successfully created filter with id '%s'", filter_transport.id)
        return Filter.from_transport(self.client, self.id, filter_transport)

    def get_filter(self, id_: str) -> "Filter":
        """Gets filter with given id.

        Args:
            id_: Id of filter.

        Returns:
            A Filter object for filter with given id.
        """
        filter_transport = SemanticLayerService.get_api_knowledge_model_layer_asset_id_filters_filter_id(
            self.client, self.id, id_
        )
        return Filter.from_transport(self.client, self.id, filter_transport)

    def get_filters(self) -> CelonisCollection["Filter"]:
        """Gets all filters of knowledge model.

        Returns:
            A list containing all filters.
        """
        filter_transports = SemanticLayerService.get_api_knowledge_model_layer_asset_id_filters(self.client, self.id)
        return CelonisCollection(
            Filter.from_transport(self.client, self.id, filter_transport)
            for filter_transport in filter_transports
            if filter_transport is not None
        )

    ############################################################
    # Content
    ############################################################
    def get_content(
        self,
        with_variable_replacement: bool = True,
        with_autogenerated_data_model_data: bool = True,
        with_default_values: bool = True,
        validate_pql: bool = True,
        with_unknown_variables_validation: bool = True,
    ) -> Optional["FinalKnowledgeModelContent"]:
        """Returns final read only content of knowledge model (including inherited properties).

        Args:
            with_variable_replacement: Specifies if variables are replaced by their values in knowledge model.
            with_autogenerated_data_model_data: Specifies whether auto generated KPIs and records for data model
                should be added to content.
            with_default_values: Specifies if default values are added to content.
            validate_pql: Specifies if PQLs in knowledge model are validated.
            with_unknown_variables_validation: Specifies if unknown variables are validated.

        Returns:
            Knowledge model content.

        Examples:
            Extract data based on PQLs from knowledge model:
            ```python
            from pycelonis.pql import (
                PQL,
                PQLColumn,
            )

            record = knowledge_model.get_content().records.find_by_id(
                "ACTIVITIES"
            )
            attribute = record.attributes.find_by_id(
                "ACTIVITY_EN"
            )

            query = (
                PQL()
                + attribute.get_column()
            )

            (
                data_query,
                query_environment,
            ) = knowledge_model.resolve_query(
                query
            )
            df = data_model.export_data_frame(
                data_query,
                query_environment,
            )
            ```
        """
        final_layer_transport = SemanticLayerService.post_api_layer_id_name_final(
            self.client,
            self.root_with_key,
            FinalModelOptions(
                with_variable_replacement=with_variable_replacement,
                with_autogenerated_data_model_data=with_autogenerated_data_model_data,
                with_default_values=with_default_values,
                validate_pql=validate_pql,
                with_unknown_variables_validation=with_unknown_variables_validation,
            ),
        )
        if final_layer_transport.layer is None:
            return None
        return FinalKnowledgeModelContent.from_transport(final_layer_transport.layer)

    def resolve_query(
        self, query: PQL, draft: bool = True, **kwargs: Any
    ) -> Tuple[DataQuery, Optional[QueryEnvironment]]:
        """Returns Data Query and Query environment for a knowledge model.

        !!! warning
            The method `knowledge_model.resolve_query` has been deprecated and will be removed in future
            versions. Please use SaolaPy from now on to export PQL queries:
                ```python
                import pycelonis.pql as pql
                from pycelonis.pql.saola_connector import (
                    KnowledgeModelSaolaConnector,
                )

                df = pql.DataFrame.from_pql(
                    query,
                    saola_connector=KnowledgeModelSaolaConnector(
                        data_model,
                        knowledge_model,
                    ),
                )
                df.head()
                ```

        Use this method to resolve queries that are based on Knowledge Model content.
        The returned DataQuery and QueryEnvironment can than be used to query data via
        [DataModel.export_data_frame][pycelonis.ems.data_integration.data_model.DataModel.export_data_frame].

        Args:
            query: PQL query to be resolved.
            draft: If true, uses draft of knowledge model, if false uses published version.
            **kwargs: Key word arguments are passed to `get_content` function.

        Returns:
            Returns Data Query and Query environment.

        Examples:
            Extract data based on PQLs from knowledge model:
            ```python
            from pycelonis.pql import (
                PQL,
                PQLColumn,
            )

            record = knowledge_model.get_content().records.find_by_id(
                "ACTIVITIES"
            )
            attribute = record.attributes.find_by_id(
                "ACTIVITY_EN"
            )

            query = (
                PQL()
                + attribute.get_column()
            )

            (
                data_query,
                query_environment,
            ) = knowledge_model.resolve_query(
                query
            )
            df = data_model.export_data_frame(
                data_query,
                query_environment,
            )
            ```
        """
        deprecation_warning(
            "knowledge_model.resolve_query",
            "Please use SaolaPy from now on to export PQL queries:\n\n"
            "\timport pycelonis.pql as pql\n"
            "\tfrom pycelonis.pql.saola_connector import KnowledgeModelSaolaConnector\n\n"
            "\tdf = pql.DataFrame.from_pql(query, "
            "saola_connector=KnowledgeModelSaolaConnector(data_model, knowledge_model))\n"
            "\tdf.head()\n\n"
            "For more information on SaolaPy, please visit "
            f"https://celonis.github.io/pycelonis/{__version__}/tutorials/executed/05_saolapy/01_saolapy_quickstart/",
        )
        return self._resolve_query(query, draft, **kwargs)

    def _resolve_query(
        self, query: PQL, draft: bool = True, **kwargs: Any
    ) -> Tuple[DataQuery, Optional[QueryEnvironment]]:
        layer = self.get_content(**kwargs)

        if layer is None:
            raise PyCelonisValueError("Can't resolve query. Knowledge model content is empty.")

        batch_request = DataCommandBatchRequest(
            variables=self._get_variables(layer),
            requests=[DataCommandBatchTransport(request=DataCommand(commands=[DataQuery(queries=query.queries)]))],
        )

        query_request = QueryRequest(batch_request=batch_request, filters=None)

        layer_compute_transport = LayerComputeTransport(
            layer=layer,
            request=query_request,
            draft=draft,
        )

        post_batch_query_transport = SemanticLayerService.post_api_knowledge_model_resolve_query(
            self.client, layer_compute_transport
        )

        knowledge_model_commands = post_batch_query_transport.analysis_commands or []
        if len(knowledge_model_commands) != 1 or knowledge_model_commands[0] is None:
            raise PyCelonisQueryResolutionError("Not the correct number of knowledge model commands resolved")

        request = knowledge_model_commands[0].request or DataCommand()
        commands = request.commands or []  # type: ignore
        if len(commands) != 1 or commands[0] is None:
            raise PyCelonisQueryResolutionError("Not the correct number of knowledge model commands resolved")

        if not post_batch_query_transport.query_environment:
            raise PyCelonisQueryResolutionError("No query environment resolved")

        return DataQuery(**commands[0].json_dict()), QueryEnvironment(
            **post_batch_query_transport.query_environment.json_dict()
        )

    def _get_variables(self, content: "FinalKnowledgeModelContent") -> List[Dict]:
        return [
            {"name": variable.id, "type": "text_replacement", "value": variable.value}
            for variable in content.variables or []
            if variable is not None
        ]

    def _create_data_export(self, query: PQL, draft: bool) -> KnowledgeModelDataExport:
        queries = " ;".join(query.queries)
        query_context = QueryContext.STUDIO if draft else QueryContext.APPS
        export_knowledge_model_request = ExportKnowledgeModelByRootWithKeyRequest(
            export_type=ProxyExportTypeV2.PARQUET, query=queries, query_context=query_context
        )
        export_query_response = (
            SemanticLayerService.post_api_knowledge_models_by_knowledge_model_root_with_key_root_with_key_exports(
                self.client, self.root_with_key, export_knowledge_model_request
            )
        )

        return KnowledgeModelDataExport.from_transport(
            self.client,
            self.root_with_key,
            query_context,  # type: ignore
            export_query_response.query_response,  # type: ignore
        )

    def _export_data_frame(self, query: PQL, draft: bool) -> pd.DataFrame:
        knowledge_model_data_export = self._create_data_export(query, draft)

        knowledge_model_data_export.wait_for_execution()

        data_frames = [read_parquet(chunk) for chunk in knowledge_model_data_export.get_chunks()]
        return pd.concat(data_frames).reset_index(drop=True)
